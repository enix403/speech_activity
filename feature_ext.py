import math
import scipy
import numpy as np
import python_speech_features as psf

from load_data import *

"""
Input: waveform (signal, frequeny)

Required:

(from paper)

sequence of 32 Ã— 32 spectrogram images
constructed by computing 32-dimensional
log-mel-filterbank energies
using a frame step of 10 ms, and
stack-ing them together over 320 ms
to form one input image.

"""

winlen = 0.025
winstep = 0.010
num_mel_filters = 32

# Number of frames to stack up for a single spectogram of the sequence
#
# One frame produces a single dimension (row of size num_mel_filters = 32)
# of the spectogram. Rows generated by multiple frames, governed by this
# number (32), are stacked on top of each other to create the image (spectogram)
# of the sequence
num_seq_frames = 32

def create_frame_labels(
    signal_labels,
    frequency
):
    # (num_frames, frame_len)
    frame_labels = psf.sigproc.framesig(
        sig=signal_labels,
        frame_len=winlen * frequency,
        frame_step=winstep * frequency,
        winfunc=np.ones
    )

    # (num_frames, 1)
    frame_labels, _ = scipy.stats.mode(frame_labels, axis=1, keepdims=True)

    return frame_labels

def calc_nfft(frequency):
    est_frame_len = int(np.round(winlen * frequency))
    return 2**int(np.ceil(np.log2(est_frame_len)))

def create_spectograms(
    signal, # list of samples: (N,)
    frequency: float, # sampling frequency (in seconds)
    signal_labels, # binary labels of each sample (N,)
):
    # Get (log) mel-filterbank energies
    # (num_frames, num_mel_filters)
    frame_emb = psf.base.logfbank(
        signal=signal,
        samplerate=frequency,
        winlen=winlen,
        winstep=winstep,
        nfilt=num_mel_filters,
        nfft=calc_nfft(frequency),
        lowfreq=0,
        highfreq=None,
    )

    # Get corresponding frame labels
    # (num_frames, 1)
    frame_labels = create_frame_labels(
        signal_labels,
        frequency
    )

    num_frames = frame_labels.shape[0]

    # Create sequence of spectograms
    seq_len = math.ceil(num_frames / num_seq_frames)

    X_seq = []
    Y_seq = []

    # TODO: check if there is a built in function for this
    for i in range(seq_len):
        start = i * num_seq_frames
        end = (i + 1) * num_seq_frames

        # (<= num_seq_frames, num_mel_filters)
        part_spectogram = frame_emb[start:end, :]

        num_frames_here = part_spectogram.shape[0]

        # (num_seq_frames, num_mel_filters)
        spectogram = np.zeros((num_seq_frames, num_mel_filters))
        spectogram[:num_frames_here, :] = part_spectogram


        # (num_seq_frames,)
        part_labels = frame_labels[start:end, 0]

        # scaler int label
        voted_label, _ = scipy.stats.mode(part_labels, axis=0)
        voted_label = int(voted_label.item())

        # Create sequence of (spectogram, voted_label)
        X_seq.append(spectogram)
        Y_seq.append(voted_label)

    # X_seq: list[(num_seq_frames, num_mel_filters)]


def load_and_extract(name: str):
    audio_path, ann_path = get_file_paths(name)

    signal, frequency = read_audio(audio_path)

    # list[(duration seconds, int label)]
    annotations = read_annotation(ann_path)

    # TODO: how to deal with rounding errors ?
    signal_labels = []
    for (duration, label) in annotations:
        num_dur_samples = int(np.round(duration * frequency))
        for _ in range(num_dur_samples):
            signal_labels.append(label)
