import os
import math

import scipy
import torch
import numpy as np
import python_speech_features as psf

winlen = 0.025
winstep = 0.010
num_mel_filters = 32

# Number of frames to stack up for a single spectogram of the sequence
#
# One frame produces a single dimension (row of size num_mel_filters = 32)
# of the spectogram. Rows generated by multiple frames, governed by this
# number (32), are stacked on top of each other to create the image (spectogram)
# of the sequence
num_seq_frames = 32

def create_frame_labels(
    signal_labels,
    frequency
):
    # (num_frames, frame_len)
    frame_labels = psf.sigproc.framesig(
        sig=signal_labels,
        frame_len=winlen * frequency,
        frame_step=winstep * frequency,
        winfunc=np.ones
    )

    # (num_frames, 1)
    frame_labels, _ = scipy.stats.mode(frame_labels, axis=1, keepdims=True)

    return frame_labels

def calc_nfft(frequency):
    est_frame_len = int(np.round(winlen * frequency))
    return 2**int(np.ceil(np.log2(est_frame_len)))

def vote_for_label(labels):
    voted_label, _ = scipy.stats.mode(labels, axis=0)
    voted_label = int(voted_label.item())
    return voted_label

def create_spectograms(
    signal, # list of samples: (N,)
    frequency: float, # sampling frequency (in seconds)
    signal_labels, # binary labels of each sample (N,)
):
    # Get (log) mel-filterbank energies
    # (num_frames, num_mel_filters)
    frame_emb = psf.base.logfbank(
        signal=signal,
        samplerate=frequency,
        winlen=winlen,
        winstep=winstep,
        nfilt=num_mel_filters,
        nfft=calc_nfft(frequency),
        lowfreq=0,
        highfreq=None,
    )

    # Get corresponding frame labels
    # (num_frames, 1)
    frame_labels = create_frame_labels(
        signal_labels,
        frequency
    )

    num_frames = frame_labels.shape[0]

    # Create sequence of spectograms
    seq_len = math.ceil(num_frames / num_seq_frames)

    chunk_idx = list(
        range(0, num_frames - num_seq_frames + 1, num_seq_frames))
    
    # list[(num_seq_frames, num_mel_filters)] of len = seq_len
    X_seq = [
        frame_emb[i:i+num_seq_frames, :]
        for i in chunk_idx
    ]

    # (seq_len,)
    Y_seq = [
        vote_for_label(frame_labels[i:i+num_seq_frames, 0])
        for i in chunk_idx
    ]

    return X_seq, Y_seq

